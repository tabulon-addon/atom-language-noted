_ = require('./utils')

# Class that enables easy dynamic generation of first-mate grammars (useful for Atom language packages)
exports.GrammarRecipe = class GrammarRecipe
  __genericComment:
    [
      "# ----------------------------------------------------------------------"
      "# ATTENTION!  If you are reading this from :"
      "#"
      "#    (a) A CoffeeScript source"
      "#"
      "#     => OK, you are in the RIGHT place. Just SKIP this comment."
      "#"
      "#    (b) any other place, such as: "
      "#          - an atom grammar definition file in CSON"
      "#          - or a dump of some sorts (that spewed oout the generated atom grammar object)"
      "#"
      "#     => STOP! You are in te WRONG place (which is an autogenerated ugly file)."
      "#        Just read the rest this comment and then go find the original"
      "#        CoffeScript source mentioned above."
      "#        It is much more pleasent to look at, I assure you. :-)"
      "#"
      "# PS: I hope you were not really thinking I was clever and crazy enough to write"
      "# that damned regex in one huge line without free-spacing :)"
      "# ----------------------------------------------------------------------"
    ]
  __defaults : { patterns: [], rules:[], repository: {}, comment: @__genericComment }
  __props    : [
      'comment',
      'name', 'scopeName', 'fileTypes', 'firstLineMatch'
      'foldingStopMarker',  'maxTokensPerLine', 'maxLineLength', 'limitLineLength'
      'injections', 'injectionSelector',
      'patterns', 'repository'
  ]
  constructor : ( opts = {} ) ->
    { @proto, @rules, @_props}  = @stash = _.defaults {}, opts, @__defaults, { _props: @__props }
    @proto ?= @stash?.grammar ? {}

    for k in @_props
      @proto[k] ?= @stash[k] if @stash?[k]?  # fill in any properties present in the stash

    @proto.repository = _.extend( @proto?.repository ? {}, @rules )

    #_.dump data: { proto: @proto, stash: @stash, props: @props}

    patterns = @proto?.patterns ? []
    @proto.patterns   = (args... ) -> fixPatterns(patterns, args... ) # Make it into a closure, to be resolved later, when needed.

  resolve:      ( opts = {} ) -> _.resolve @proto, _.defaults( {}, opts, @stash )
  bake:         ( opts = {} )   -> @resolve opts   # just an alias for @resolve(...)


exports.fixPatterns   = fixPatterns = (patterns = [], m = {}, args... ) ->
    res = []
    for p in patterns
      pattern = fixPattern p, m, args...
      continue if _.isUndefined(pattern)
      res.push pattern
    return res

exports.fixPattern    = fixPattern = ( pattern, m, args... ) ->
    pattern = _.resolve(pattern, m, args...) unless _.isUndefined(pattern)
    # return pattern # @@DEBUG. -@FIXME. Just remove this line when things settle.
    switch
      when _.isUndefined(pattern) then return pattern
      when _.isObject(pattern)
        return pattern unless pattern.include?
        ref = String(pattern.include)
      else
        ref = String(pattern)
        pattern = new Object()

    ruleName = ref.replace(/^[#]/, '')
    return undefined if (m?.disable?[ruleName] ? false ) or (m?.disable?[ '#' + ruleName] ? false )

    pattern.include = '#' + "#{ruleName}"
    return  pattern


#exports.writeGrammar = writeGrammar = (grammar, how ='CSON' ) -> helper.makeGrammar grammar, how
exports.buildCaptures = buildCaptures = ( args... ) ->
  caps = args
  caps  = caps.map (item) -> if _.isString(item) then { name: item } else item
  capso = {}
  for i in [0 ... caps.length ]
    v = caps[i]
    capso[ i ] =  v unless _.isUndefined(v)    # !@NOTE that the left-hand-side is an object with numeric keys (but not an ARRAY). That's why we need the loop.
  return capso
