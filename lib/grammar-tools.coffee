_ = require('./utils')

# Class that enables easy dynamic generation of first-mate grammars (useful for Atom language packages)
exports.GrammarRecipe = class GrammarRecipe
  _genericRemarks:
    [
      "# ----------------------------------------------------------------------"
      "# ATTENTION!  If you are reading this from :"
      "#"
      "#    (a) A CoffeeScript source"
      "#"
      "#     => OK, you are in the RIGHT place. Just SKIP this comment."
      "#"
      "#    (b) any other place, such as: "
      "#          - an atom grammar definition file in CSON"
      "#          - or a dump of some sorts (that spewed oout the generated atom grammar object)"
      "#"
      "#     => STOP! You are in te WRONG place (which is an autogenerated ugly file)."
      "#        Just read the rest this comment and then go find the original"
      "#        CoffeScript source mentioned above."
      "#        It is much more pleasent to look at, I assure you. :-)"
      "#"
      "# PS: I hope you were not really thinking I was clever and crazy enough to write"
      "# that damned regex in one huge line without free-spacing :)"
      "# ----------------------------------------------------------------------"
    ]
  _props: [
    'comment',
    'name', 'scopeName', 'fileTypes', 'firstLineMatch'
    'foldingStopMarker',  'maxTokensPerLine', 'maxLineLength', 'limitLineLength'
    'injections', 'injectionSelector',
    'patterns', 'repository'
  ]
  props:    () -> @_props
  remarks:  () -> @_genericRemarks

  # You may wish to override the below.
  defs :    () -> { patterns: [], repository: {}, comment: @remarks() }
  vars :    () -> { }
  rules:    () -> {} # you may wish to override this!

  # Generic constructor should suffice in most cases,
  #   -- provided that you have appropriately overridden the above: e.g. defs(), vars(), rules()
  constructor : ( opts = {} )   ->
    # fill in defaults and options
    { @proto, @filename }  = @stash = _.defaults {}, opts, @vars(), @defs()

    # some critical defaults
    @proto    ?= @stash?.grammar ? {}
    @filename ?= arguments?.caller?.__filename

    # fill in the properties of 'proto' (grammar), from the stash.
    # Note that some of those properties may contain function references at this time (instead of plain values)
    # No problem: those will be invoked when we finally 'resolve()' (bake) the grammar.
    for k in @props()
      @proto[k] ?= @stash[k] if @stash?[k]?  # fill in any properties present in the stash

    # other critical defaults
    {@name, @scopeName} = @proto
    @disabled  = if @name? then @stash?.disable?[@name.toLowerCase()] ? false else false  # determine if the entire grammar should be disabled.

    # patterns
    switch
      when @disabled then @proto.patterns = []  # if the entire grammar is disabled, we make sure 'patterns' is empty.
      else
        patterns = @proto?.patterns ? []
        @proto.patterns   = (args... ) -> fixPatterns(patterns, args... ) # Make it into a closure, to be resolved later, when needed.

    # repository
    @proto.repository   = _.extend @proto?.repository ? {}, @rules?(@stash) ? {}
    #_.dump data: { proto: @proto, stash: @stash, props: @props}

  resolve:      ( opts = {} )   -> _.resolve @proto, _.defaults( {}, opts, @stash )
  bake:         ( opts = {} )   -> @resolve opts   # just an alias for @resolve(...)

  # atom releated routines
  tmUpdate:     ( args... ) -> @tmRetire args... ; @tmRegister args...
  tmRegister:   ( args... ) -> atom?.grammars?.addGrammar @tmCreate args...
  tmCreate:     ( args... ) -> atom?.grammars?.createGrammar @filename, @resolve(args...)
  tmRetire:     ( args... ) -> atom?.grammars?.removeGrammarForScopeName @scopeName




exports.fixPatterns   = fixPatterns = (patterns = [], m = {}, args... ) ->
    res = []
    for p in patterns
      pattern = fixPattern p, m, args...
      continue if _.isUndefined(pattern)
      res.push pattern
    return res

exports.fixPattern    = fixPattern = ( pattern, m, args... ) ->
    pattern = _.resolve(pattern, m, args...) unless _.isUndefined(pattern)
    # return pattern # @@DEBUG. -@FIXME. Just remove this line when things settle.
    switch
      when _.isUndefined(pattern) then return pattern
      when _.isObject(pattern)
        return pattern unless pattern.include?
        ref = String(pattern.include)
      else
        ref = String(pattern)
        pattern = new Object()

    ruleName = ref.replace(/^[#]/, '')
    return undefined if (m?.disable?[ruleName] ? false ) or (m?.disable?[ '#' + ruleName] ? false )

    pattern.include = '#' + "#{ruleName}"
    return  pattern


#exports.writeGrammar = writeGrammar = (grammar, how ='CSON' ) -> helper.makeGrammar grammar, how
exports.buildCaptures = buildCaptures = ( args... ) ->
  caps = args
  caps  = caps.map (item) -> if _.isString(item) then { name: item } else item
  capso = {}
  for i in [0 ... caps.length ]
    v = caps[i]
    capso[ i ] =  v unless _.isUndefined(v)    # !@NOTE that the left-hand-side is an object with numeric keys (but not an ARRAY). That's why we need the loop.
  return capso

exports.prescribe = prescribe = {}

prescribe.wordlists = ( m = {}, re = {}, schema )  ->
  return unless models = schema?.words
  return unless prefix = schema?.prefix ? { mode:1, cc:/[@$]/.source }
  return if schema?.disabled

  patterns = []
  for i in m.spirits
    continue unless w = models?[i]
    model = _.extend {}, { prefix }, w
    patterns.push prescribe.wordlist( m, re, model, i)

  return {patterns: patterns}

prescribe.wordlist = ( m = {}, re = {}, model, mood )  ->
  return unless w = model
  return if w?.disabled

  mood   = w?.mood  ? w?.spirit ? mood ? 'neutral'
  truly  = m?.so?[mood] ? ''

  re_words  = w?.re_words ? w?.rewords ?  w?.regex
  re_words ?= w if _.isString(w) || _.isRegExp(w)
  return unless re_words

  pcc    = w?.prefix?.cc    || /[@#]/.source
  pmod   = w?.prefix?.mode  || 1
  switch
    when (pmod & 4) != 0  then re_head = ""         # forbidden
    when (pmod & 2) != 0  then re_head = pcc        # required
    else
      re_head = pcc + '?'

  re_head  = _.resolve(re_head)
  re_words = _.resolve(re_words)

  return {
    match: ///
      (?:^|\s|\W)
      ((                                                          # $1, $2
        (#{re_head})                                              # $3
        ((#{re_words}))                                           # $4, $5
      ))
      \b
    ///.source
    captures:
      1: name: "meta.notelet.term.#{m.noted}"
      2: name: "#{m.poke}.term.#{truly}.#{m.noted}"
      3: name: "#{m.poke}.head.#{truly}.#{m.noted}"
      4: name: "#{m.poke}.body.#{truly}.#{m.noted}"
      5: name: "#{m.poke}.marrow.#{truly}.#{m.noted}"
  } # END: return
