###
  #---------------------------------------------------------------------------------------
  # Below are a bunch of tokens for a quick reference and also a brief visual test for [language-noted].
  #
  # ~@AUTHOR @@MENTION   #@HASHTAGGY :@EAGER ,@BLAND ;@DULL &@VERBOSE +@GOOD ?@QUESTION  >@PERTINENT !@ALERT *@FISHY -@BAD %@SHAKY _@SPOOKY @NONE
  # ~#AUTHOR @#MENTIONNY ##HASHTAG   :#EAGER ,@BLAND ;@DULL &@VERBOSE +#GOOD ?#QUESTION  >#PERTINENT !#ALERT *#FISHY -#BAD %#SHAKY _#SPOOKY #NONE
  #
  # RADAR:  <radar://issue/124> (radar links are always rendered the same as >@PERTINENT)
  #
  # Quoted strings, either with +@"double quotes" or ;#'single quotes', as well as .+@[bracket quoted] forms should also work:
  # This includes quote-like usage of brackets and parenthehis, such as ,#<angle bracket> , #@[square bracket], and also ;#(parenthetic quotes).
  #
  # Backslash escaping ;@"should \"work\" as expected" for all the quote-like operators mentioned above.
  #
  # Note that, in this context, brackets and parenthesis act just like quotatation marks, except the fact that the end of the quotation is marked with a
  # specific character which is distinct (yet still discernable) from the opening character. In particular,  balanced nesting of parens/brackets
  # is not required and does not even make much sense in a quotation context.
  #
  # The careful reader might have noticed that curly braces '{}' and backticks have not been mentioned among the quote-like operators described above.
  # This is intentional as those are %#reserved for the moment.
  #
  # falanca, filanca RADAR_TEST_NOTED NOTELET_TEST_NOTED gibi
  #---------------------------------------------------------------------------------------
+@FINE
###

{makeGrammar, rule} = require('atom-syntax-tools')

warningTextLines = () ->
  [
    "# ----------------------------------------------------------------------"
    "# ATTENTION!  If you are reading this from :"
    "#"
    "#    (a) the original CoffeeScript source (lib/grammar.cofee)"
    "#"
    "#     => OK, you are in the RIGHT place. Just SKIP this comment."
    "#"
    "#    (b) any other place, such as: "
    "#          - an atom grammar definition file in CSON"
    "#          - or a dump of some sorts (that spewed oout the generated atom grammar object)"
    "#"
    "#     => STOP! You are in te WRONG place (which is an autogenerated ugly file)."
    "#        Just read the rest this comment and then go find the original"
    "#        CoffeScript source mentioned above."
    "#        It is much more pleasent to look at, I assure you. :-)"
    "#"
    "# PS: I hope you were not really thinking I was clever and crazy enough to write"
    "# that damned regex in one huge line without free-spacing :)"
    "# ----------------------------------------------------------------------"
  ]
stash = () -> {
  # macro support is provided by [atom-syntax-tools]
  # Here are some examples (direct from [atom-syntax-tools] )
  en: "entity.name"
  pd: "punctuation.definition"
  ps: "punctuation.separator"
  ii: "invalid.illegal"

  # And here's our own macros

  # for pun :-)
  noted : 'text.noted'                              # The SUFFIX that we append on all scopes we mark on our captures.
  poke : 'markup.standout'                          # Our main scope PREFIX;
  punk : 'punctution.definition.notelet.standout'   # Punction scope PREFIX
  link : 'markup.underline.link'
  radar : "markup.radar.standout.spirit-pertinent"

  gladly : 'spirit-${4:/downcase}${5:/downcase}${6:/downcase}${7:/downcase}.vigor-${8:/downcase}'
  pertinently : "standout.spirit-pertinent"
  }

rule_notelet = (v) ->
  v ?= stash()

  # Regex character classes
  cc_bareword =      /[0-9A-Za-z\-._]/       # Char class for bareword (unquoted) standouts. !@Note the extra dash (-) and period (.) in addition to the usual suspects.
  cc_spirit_name =   /[0-9A-Za-z_]/          # Char class for spirit names such as : alert, good, bad, ...
  cc_spirit_symbol = /[%_\-*!>+?:\,;&~#@]/   # Char class for spirit marker symbols (for shorthand notation)

  # Below being able to use -#<branch resets>  (:| ... ) would have come so handy, but JavaScript doesn't support it.
  # Hence the hack below which involves concatenting separately numbered capture groups from different alternatives,
  # (relying on the fact that only one of them will be non-empty for any given match)

  # @@NOTE that in what follows, capture group numbers continue where they left off in the previous regex term
  # This is natuarally as expected; since they are finally gathered into one bug regex (re_notelet_term)
  # ALos @@NOTE that empty regexen that will be interpolated elsewhere MUST be denoted with double-quotes (seemingly due to a CoffeeScript bug as of 2018-07)

                                                              # !@ATTENTION: Regex "comments" are not reported as being comments by [language-coffescript.]
                                                                # Therefore [language-noted] syntax-highliting won't work within these
  re_match = ///
    (?:\s|^)
          # NOTELET is not allowed to be immediately preceded by word characters.
          # STOP! Don't even think of using (?<!\w) here! That does NOT work when the grammar is loaded dynamically by Atom,
          # giving an 'Invalid group' error or the regex, although it works perfectly fine on the with 'coffee', go figure...
          # (It has probably got something to do with the version of 'coffescript' or 'node.js' that are being used by
          # my current version of Atom (v1.28.2 -  64bit MacOS build)

    (                                                         # < 1: < NOTELET-term             // The entire notelet expression that has matched

      # <<<<<<< BEGIN: spirit-term
      (                                                       # < 2:  < SPIRIT-term             // Only the portion BEFORE the reftype character (#@)
        (                                                     # < 3:    < desginator
          (?:   # A branch reset (:| ... ) needed here, but NOT supported by JS, as explained above. So we end up with a gziliian capture groups.
                # Therefore "spirit marker" is later expressed as a fake concatination like below:
                #       ${4:/downcase}${5:/downcase}${6:/downcase}${7:/downcase}
                (?: [<]?   ([%_\-*!>+?:\,;&~#@])+?   [>]?  )  #           $4
             |  (?: \(        ([0-9A-Za-z_]+)       \)     )  #           $5
             |  (?: \[        ([0-9A-Za-z_]+)       \]     )  #           $6
             |  (?: \{        ([0-9A-Za-z_]+)       \}     )  #           $7

          )                                                   # alternation
        )                                                     # > 3;    > desginator
        ((?:[0-9])?)                                     # . 8:    . vigor. UNDOCUMENTED for the moment.
      )                                                       # > 2:  > SPIRIT-term
      # >>>>>>> END: spirit-term


      # <<<<<<< BEGIN: standout-term
      (                                                       # < 9:  < standout-rem
        ([#@])                                                # . 10:    . head
        (                                                     # < 11:    < body

          (?:   # A branch reset (:| ... ) needed here, but NOT supported by JS, as explained above. So, we end up with a gziliian capture groups.
                # As a consequence, all of the following captures are programattically marked the same in consquetive triplets ('core.start' 'core' 'core.end').

              (?: (  )  ( [0-9A-Za-z\-._]+ )      (  )  \b)       # * 12, 13, 14: BAREWORD label that also accepts dashes and periods
                                                                  # // Note the EMPTY capture groups.
                                                                  # // Also note that '\b' is employed just here, and not at the very end nor with quoted expressions!

                                                                  # Quote-like expressions with backslash escaping support
            | (?: ( ')  ( (?: [^'\\]|[\\]. )*  )  ( ')   )        # * 15, 16, 17: 'Single quoted' expression
            | (?: ( ")  ( (?: [^"\\]|[\\]. )*  )  ( ")   )        # * 18, 19, 20: "Doubled quoted" expression

            | (?: ( <)  ( (?: [^>\\]|[\\]. )*  )  ( >)   )        # * 21, 22, 23: <Angle-bracket quoted>  expression
            | (?: (\()  ( (?: [^)\\]|[\\]. )*  )  (\))   )        # * 24, 25, 26: (Parenthesis quoted)    expression
            | (?: (\[)  ( (?: [^\]\\]|[\\].)*  )  (\])   )        # * 27, 28, 29: (Square-bracket quoted) expression
          )                                                       # ALTERNATION
        )                                                         # > 11     > body
      )                                                           # > 9   > standout-term
      # >>>>>>> END: standout-term

      )                                                         # > 1 > NOTELET-TERM
  ///


  rule = {
    match: re_match
    #match: match.source
    captures:
      1: name:  "meta.notelet.term.#{v.noted}"
      2: name:  "#{v.punk}.spirit.term.#{v.noted}"
      3: name:  "#{v.punk}.spirit.designation.#{v.noted}"   # similar to 'marker' below, but includes the whole string in case of delimited (or repeated) marker (symbol.)
      4: name:  "#{v.punk}.spirit.marker.#{v.noted}"
      5: name:  "#{v.punk}.spirit.marker.#{v.noted}"
      6: name:  "#{v.punk}.spirit.marker.#{v.noted}"
      7: name:  "#{v.punk}.spirit.marker.#{v.noted}"
      8: name:  "#{v.punk}.spirit.vigor.#{v.noted}"
      9: name:  "#{v.poke}.term.#{v.gladly}.#{v.noted}"
      10: name: "#{v.poke}.head.#{v.gladly}.#{v.noted}"
      11: name: "#{v.poke}.body.#{v.gladly}.#{v.noted}"

      # !@NOTE that the rest of the capturesare set actually set programmatically below, trying to keep things DRY.
      #
      # This is because captures for 'core' have to be given multiple times in a row for each separate capture-group generated by aalternation (|)
      # bewteen various forms of quote-like constructs (as explained in the margins of regex comments above).

  } # END: notelet

  # The following is done for the sake of DRY. It makes for more lines of code (but hop.termy more maintainable)
  # note that macros below are expanded by makeGrammar, just like the other macros elsewhere.
  core_quoted_forms = [ 'single', 'double', 'angle_bracket', 'square_bracket', 'parens' ]
  core_caps_std = [
    { name: "#{v.punk}.core.start.#{v.noted}"     },
    { name: "#{v.poke}.core.#{v.gladly}.#{v.noted}"  },
    { name: "#{v.punk}.core.end.#{v.noted}"       }
  ]
  core_caps = []
  for i in [0 ... core_quoted_forms.length + 1 ]   # + 1 for the regular bareword form.
    core_caps = core_caps.concat core_caps_std

  #  caps = graw.repository['notelet']['captures']
  caps = rule['captures']

  core_caps_start= 1 + Math.max (key for key of caps)...  # we count on the fact that the keys of the 'captures' object are always numbers.
  for i in [0 ... core_caps.length]
    caps[ i + core_caps_start ] = core_caps[i]  # !@NOTE that the left-hand-side is an object (not an ARRAY. That's why we need the loop instead of 'concat')

  return rule


rawGrammar = (args...) ->
  v = stash()
  graw = {
    name: 'Noted'
    scopeName: 'text.noted'
    injectionSelector: 'comment, text.plain'

    comment: warningTextLines()
    patterns: [
      { include: '#notelet' },
      { include: '#radar'   }
    ]

    repository: {
      notelet: rule_notelet(v)
      radar: { # For language-TODO emulation.
        match: /((<)((ra?dar:\/(?:[\/](problems?|issues?|tickets?|bug-reports?|bugs?|reports?))\/([&0-9 .%;A-Aa-z_]+)))(>))/.source
        #match: '(RADAR_TEST_NOTED)'
        name: "storage.type.class.radar.#{v.pertinently}.#{v.noted}"   # This one is for language-todo/-more-words compatibility
        captures:
          1: name: "meta.radar.#{v.noted}"
          2: name: "#{v.punk}.radar.start.#{v.noted}"
          3: name: "#{v.link}.radar.body.#{v.pertinently}.#{v.noted}"  # radar.body is marked twice. This one is for language-todo/-more-words compatibility
          4: name: "#{v.radar}.body.#{v.noted}"                    #                             And this one is in our own way.
          5: name: "#{v.radar}.type.#{v.noted}"
          6: name: "#{v.radar}.core.#{v.noted}"
          7: name: "#{v.punk}.radar.end.#{v.noted}"
      } # END: radar
    } # END: repository
  } # END: grammar

  return graw

grammar = (args... ) ->
  return mkGrammar args...

mkGrammar = (args... ) ->
  g = rawGrammar()
  makeGrammar g, args...

writeGrammar = ( how ) ->
  how ?= 'CSON'
  mkGrammar how

run = (args...) ->
  writeGrammar(args...)

#run()   # # print out a CSON version on STDOUT - (needed only when the grammar generation happens during a build)

module.exports =
  # essential
  grammar: (args...) -> grammar(args...)
  run: (args...) -> run(args...)

  # others
  mkGrammar: (args...) -> mkGrammar(args...)
  rawGrammar: (args...) -> rawGrammar(args...)
  writeGrammar: (args...) -> writeGrammar(args...)
